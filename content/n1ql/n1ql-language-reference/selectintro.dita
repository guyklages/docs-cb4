<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="topic_xwp_r3k_dx">
  <title>Overview</title>
  <shortdesc>With the SELECT statement, you can query and manipulate JSON data. You can select, join, project, nest, unnest, group, and sort in a single SELECT statement.
  </shortdesc>
  <body>
    <p>The SELECT statement takes a set of JSON documents from keyspaces as its input, manipulates
      it and returns a set of JSON documents in the result array. Since the schema for JSON
      documents is flexible, JSON documents in the result set have flexible schema as well.</p>
    <p>A simple query in N1QL consists of three parts: <ol id="ol_c2w_gf3_11b">
        <li>SELECT: specifies the projection, which is the part of the document that is to be
          returned. </li>
        <li>FROM: specifies the keyspaces to work with. </li>
        <li>WHERE: specifies the query criteria (filters or predicates) that the results must
          satisfy.</li>
      </ol></p>
    <p>To query on a keyspace, you must either specify the document keys or use an index on the
      keyspace. </p>
    <p/>
    <p><b>RBAC Privileges</b></p>
    <p>User executing the SELCET statement must have the <i>Query Select</i> privileges granted on
      all keyspaces referred in the query. Note that, the SELECT query may not refer to any keyspace
      or with JOIN queries or subqueries, it may refer to multiple keyspaces. For more details about
      user roles, see <xref href="../../security/security-authorization.dita#authorization"/>.</p>
    <p>For example, </p>
    <p>To execute the following statement, user does not need any special privileges.</p>
    <p>
      <codeblock outputclass="language-json">SELECT 1</codeblock>
    </p>
    <p>To execute the following statement, user must have the <i>Query Select</i> privilege
        on<codeph> `travel-sample`</codeph>.</p>
    <p>
      <codeblock outputclass="language-json">SELECT * FROM `travel-sample` </codeblock>
    </p>
    <p>To execute the following statement, user must have the <i>Query Select</i> privilege
        on<codeph> `travel-sample`</codeph> and <codeph>`beer-sample`</codeph>.</p>
    <p>
      <codeblock outputclass="language-json">SELECT * FROM `travel-sample` t  
JOIN `beer-sample` b 
ON KEYS ["aldaris", "ale_asylum"]</codeblock>
    </p>
    <p>To execute the following statement, user must have the <i>Query Select</i> privilege on
        <codeph>`travel-sample`</codeph> and <codeph>`beer-sample`</codeph>.</p>
    <p>
      <codeblock outputclass="language-json">SELECT * FROM `travel-sample` 
WHERE city 
IN (SELECT raw city FROM `beer-sample`)</codeblock>
    </p>
    <p>To execute the following statement, user must have the <i>Query Select</i> privilege on
        <codeph>`travel-sample`</codeph> and <codeph>`beer-sample`</codeph>.</p>
    <p>
      <codeblock outputclass="language-json">SELECT * FROM `travel-sample` WHERE type = "hotel"
UNION 
SELECT * FROM `beer-sample` WHERE type = "brewery"</codeblock>
    </p>
    <p/>
    <p>The following example uses an index to query the keyspace for airports that are in the
      America/Anchorage timezone and at an altitude of 2100ft or higher, and returns an array with
      the airport name and city name for each airport that satisfies the
      conditions.<codeblock outputclass="language-json" spectitle="Query">SELECT t.airportname, t.city
FROM   `travel-sample` t
WHERE  type = "airport" 
       AND tz = "America/Anchorage" 
       AND geo.alt >= 2100;</codeblock><codeblock outputclass="language-json" spectitle="Results">Results:
[
   {
         "airportname": "Anaktuvuk Pass Airport",
         "city": "Anaktuvuk Pass",
   }
]</codeblock></p>
    <p>The next example queries the keyspace using the document key
        "<userinput>airport_3469</userinput>".
      <codeblock outputclass="language-json" spectitle="Query">SELECT * FROM `travel-sample` USE KEYS "airport_3469";</codeblock><codeblock outputclass="language-json" spectitle="Result">Results:
[
  {
    "travel-sample": {
      "airportname": "San Francisco Intl",
      "city": "San Francisco",
      "country": "United States",
      "faa": "SFO",
      "geo": {
        "alt": 13,
        "lat": 37.618972,
        "lon": -122.374889
      },
      "icao": "KSFO",
      "id": 3469,
      "type": "airport",
      "tz": "America/Los_Angeles"
    }
  }
]</codeblock></p>
    <p>With projections, you retrieve just the fields that you need and not the entire document.
      This is especially useful when querying for a large dataset as it results in shorter
      processing times and better performance.</p>
    <p>The SELECT statement provides a variety of data processing capabilities such as <xref
        href="#topic_xwp_r3k_dx/filtering" format="dita">filtering</xref>, <xref
        href="#topic_xwp_r3k_dx/query-across-relationships" format="dita">querying across
        relationships</xref> using JOINs or subqueries, <xref
        href="#topic_xwp_r3k_dx/deep-traversal-nested-docs" format="dita">deep traversal of nested
        documents</xref>, <xref href="#topic_xwp_r3k_dx/aggregation" format="dita"
        >aggregation</xref>, <xref href="#topic_xwp_r3k_dx/combine-resultsets" format="dita"
        >combining result sets</xref> using operators, <xref
        href="#topic_xwp_r3k_dx/group-sort-limit" format="dita">grouping</xref>, <xref
        href="#topic_xwp_r3k_dx/group-sort-limit" format="dita">sorting</xref>, and more. Follow the
      links for examples that demonstrate each capability.</p>
 <section><title>SELECT Statement Processing</title>
   <p>The SELECT statement queries a keyspace and returns a JSON array that contains zero or more objects.</p>
   <p>The following diagram shows the query execution workflow at a high level and illustrates the
        interaction with the query, index, and data services. <fig id="fig_knp_lkk_dx">
          <title>Query Execution Workflow</title>
          <image placement="break" href="images/query_execution.png" width="570"
            id="image_lnp_lkk_dx"/>
        </fig></p>
   <p>The SELECT statement is executed as a sequence of steps. Each step in the process produces result objects that are then used as inputs in the next step until all steps in the process are complete. While the workflow diagram shows all the possible phases a query goes through before returning a result, the clauses and predicates in a query decide the phases and the number of times that the query goes through. For example, sort phase can be skipped when there is no ORDER BY clause in the query; scan-fetch-join phase will execute multiple times for correlated subqueries.</p>
   <p>The following diagram shows the possible elements and operations during query execution.
        <fig id="fig_t4d_c35_gx">
          <title>Query Execution Phases</title>
          <image placement="break" href="images/query_service.svg" width="670" height="300"
            id="image_u4d_c35_gx"/>
        </fig></p>
   <p>The possible elements and operations in a query include: <ul>
     <li>Specifying the keyspace that is queried.</li>
          <li>Specifying the document keys or using indexes to access the documents. </li>
          <li>Fetching the data from the data service. </li>
          <li>Filtering the result objects by specifying conditions in the WHERE clause. </li>
          <li>Removing duplicate result objects from the resultset by using the DISTINCT clause. </li>
          <li>Grouping and aggregating the result objects. </li>
          <li>Ordering (sorting) items in the resultset in the order specified by the ORDER BY
            expression list. </li>
          <li>Skipping the first<varname> n </varname>items in the result object as specified by the
            OFFSET clause. </li>
          <li>Limiting the number of results returned using the LIMIT clause. </li>
   </ul></p>
 </section>
    <section><title>Data Processing Capabilities</title>
      <dl>
        <dlentry id="filtering">
          <dt>Filtering</dt>
          <dd>You can filter the query results using the WHERE clause. Consider the following
            example which queries for all airports in the America/Anchorage timezone that are at an
            altitude of 2000ft or more. The WHERE clause specifies the conditions that must be
            satisfied by the documents to be included in the resultset, and the resultset is
            returned as an array of airports that satisfy the condition. <note>The keys in the
              result object are ordered alphabetically at each
            level.</note><codeblock outputclass="language-json" spectitle="Query">SELECT * 
FROM   `travel-sample` 
WHERE  type = "airport" 
       AND tz = "America/Anchorage" 
       AND geo.alt >= 2000; </codeblock><codeblock outputclass="language-json" spectitle="Result">Results:
[
   {
      "travel-sample": {
         "airportname": "Anaktuvuk Pass Airport",
         "city": "Anaktuvuk Pass",
         "country": "United States",
         "faa": "AKP",
         "geo": {
            "alt": 2103,
            "lat": 68.1336,
            "lon": -151.743
         },
         "icao": "PAKP",
         "id": 6712,
         "type": "airport",
         "tz": "America/Anchorage"
      }
   },
   {
      "travel-sample": {
         "airportname": "Arctic Village Airport",
         "city": "Arctic Village",
         "country": "United States",
         "faa": "ARC",
         "geo": {
            "alt": 2092,
            "lat": 68.1147,
            "lon": -145.579
         },
         "icao": "PARC",
         "id": 6729,
         "type": "airport",
         "tz": "America/Anchorage"
      }
   }
]</codeblock></dd>
        </dlentry>
        <dlentry id="query-across-relationships">
          <dt>Querying Across Relationships</dt>
          <dd><p>You can use the SELECT statement to query across relationships using the JOIN
              clause or subqueries.</p><b>JOIN Clause</b><p>Before we delve into examples, let's
              take a look at the data model of the travel-sample keyspace, which is used in the
              following examples. For more details about the data model, see <xref
                href="../../travel-app/travel-app-data-model.dita#concept_hyy_k1z_pr"/>.<fig
                id="fig_fgp_14k_dx">
                <title>Data model of travel-sample keyspace</title>
                <image placement="break" href="../../travel-app/images/travel-app-data-model.png"
                  width="570" id="image_ggp_14k_dx"/>
              </fig></p><p><b>Example 1</b>:  Use a JOIN clause to find the distinct airline details
              which have routes that start from SFO. This example JOINS the document of type<codeph>
                route </codeph>with documents of type<codeph> airline </codeph>using the KEY<codeph>
                airlineid</codeph>.<ul id="ul_frq_g4k_dx">
                <li>Documents of type<codeph> route </codeph>are on the left side of JOIN, and
                  documents of type<codeph> airline </codeph>are on the right side of JOIN. </li>
                <li>The documents of type<codeph> route </codeph>(on the left) contain the foreign
                    key<codeph> airlineid </codeph>of documents of type<codeph> airline </codeph>(on
                  the right). </li>
              </ul><codeblock outputclass="language-json" spectitle="Example 1: Query">SELECT DISTINCT airline.name, airline.callsign, route.destinationairport, route.stops, route.airline
FROM `travel-sample` route 
  JOIN `travel-sample` airline 
  ON KEYS route.airlineid 
WHERE route.type = "route" 
  AND airline.type = "airline" 
  AND route.sourceairport = "SFO" 
LIMIT 2;</codeblock><codeblock outputclass="language-json" spectitle="Example 1: Results">Results:
[
   {
      "airline": "SY",
      "callsign": "SUN COUNTRY",
      "destinationairport": "MSP",
      "name": "Sun Country Airlines",
      "stops": 0
   },
   {
      "airline": "UA",
      "callsign": "UNITED",
      "destinationairport": "IND",
      "name": "United Airlines",

      "stops": 0
   }
]</codeblock></p><p><b>Example
                2</b>:  Find the number of distinct airports where<codeph> AA </codeph>has routes.
              In this example: <ul id="ul_gy2_npk_dx">
                <li>Documents of type<codeph> airline </codeph>are on the left side of JOIN, and
                  documents of type<codeph> route </codeph>are on the right side.</li>
                <li>The WHERE clause predicate<codeph> airline.iata = "AA" </codeph>is on the right
                  side keyspace<codeph> airlines</codeph>.</li>
              </ul></p><p>This example illustrates a special kind of JOIN where the documents on the
              right side of JOIN contain the foreign key reference to the documents on the left
              side. Such JOINs are referred to as index JOIN. See <xref
                href="from.dita#concept_rnt_zfk_np/join-clause"/> for more details.</p><p>Index JOIN
              requires a special inverse index<codeph> route_airlineid </codeph>on the JOIN
                key<codeph> route.airlineid</codeph>. Create this index using the following command:
              <codeblock outputclass="language-json">CREATE INDEX route_airlineid ON `travel-sample`(airlineid) 
WHERE type = "route";</codeblock></p><p>Now
              we can execute the following query.
              <codeblock outputclass="language-json" spectitle="Example 2: Query">SELECT Count(DISTINCT route.sourceairport) AS distinctairports1 
FROM `travel-sample` airline 
  JOIN `travel-sample` route 
  ON KEY route.airlineid FOR airline 
WHERE  route.type = "route" 
  AND    airline.type = "airline" 
  AND    airline.iata = "AA";</codeblock><codeblock outputclass="language-json" spectitle="Example 2: Results">Results:
[
   {
      "distinctairports1": 429
   }
]</codeblock></p></dd>
          <dd><b>Subqueries</b><p>A subquery is an expression that is evaluated by executing an
              inner SELECT query. Subqueries can be used in most places where you can use an
              expression such as projections, FROM clauses, and WHERE clauses. </p><p>A subquery is executed once for every input document to the outer statement and it returns an
              array every time it is evaluated. See <xref href="subqueries.dita#topic_9"/> for more
              details.
              <codeblock outputclass="language-json" spectitle="Query">SELECT * 
FROM   (SELECT t.airportname 
        FROM   (SELECT * 
                FROM   `travel-sample` t 
                WHERE  type = "airport" 
                       AND country = "United States" 
                LIMIT  1) AS s1) AS s2;</codeblock><codeblock outputclass="language-json" spectitle="Results">Results:
[
   {
      "s2": {
         "airportname": "Barter Island Lrrs"
      }
   }
]</codeblock></p></dd>
        </dlentry>
        <dlentry id="deep-traversal-nested-docs">
          <dt>Deep Traversal for Nested Documents</dt>
          <dd>When querying a bucket with nested documents, SELECT provides an easy way to traverse
            deep nested documents using the dot notation and NEST and UNNEST clauses. <p>The
              following query looks for the schedule, and accesses the flight id for<codeph>
                destinationaiport=ALG</codeph>. Since a given flight has multiple schedules,
                attribute<codeph> schedule </codeph>is an array containing all schedules for the
              specified flight. You can access the individual array elements using the array
              indexes. For brevity, weâ€™re limiting the number of query results to 1.
              <codeblock outputclass="language-json" spectitle="Query">SELECT t.schedule[0].flight AS flightid 
FROM `travel-sample` t 
WHERE type="route" 
  AND destinationairport="ALG" 
LIMIT 1;</codeblock><codeblock outputclass="language-json" spectitle="Results">Results:
[
   {
      "flightid": "AH631"

   }
]</codeblock></p></dd>
          <dd><b>NEST and UNNEST</b><p>When using NEST, an array is created with the matching nested
              documents. </p><p><b>Example 3</b>:  Use the NEST clause to list all AA airline
              routes.  In this example: <ul id="ul_iph_w33_11b">
                <li>The<codeph> airline </codeph>field in the result is an array of the<codeph>
                    `travel-sample` </codeph>documents that are matched with the key<codeph>
                    route.airlineid</codeph>.</li>
                <li>Hence, the projection is accessed as<codeph> airline[0] </codeph>to pick the
                  first element of the array.</li>
              </ul><codeblock outputclass="language-json" spectitle="Query">SELECT DISTINCT route.sourceairport, 
                route.airlineid, 
                airline[0].callsign 
FROM `travel-sample` route NEST `travel-sample` airline 
  ON KEYS route.airlineid 
WHERE route.type = "route" 
  AND route.airline = "AA" 
LIMIT 4;</codeblock><codeblock outputclass="language-json" spectitle="Results">Results:
[
   {
      "airlineid": "airline_24",
      "callsign": "AMERICAN",
      "sourceairport": "ITH"
   },
   {
      "airlineid": "airline_24",
      "callsign": "AMERICAN",
      "sourceairport": "WAW"
   },
   {
      "airlineid": "airline_24",
      "callsign": "AMERICAN",
      "sourceairport": "BKK"
   },
   {
      "airlineid": "airline_24",
      "callsign": "AMERICAN",
      "sourceairport": "GGT"
   }
]</codeblock></p><p><b>Example
                4</b>:  Use the UNNEST clause to retrieve the<codeph> author </codeph>names from
                the<codeph> reviews
              </codeph>object.<codeblock outputclass="language-json" spectitle="Query">SELECT r.author 
FROM `travel-sample` t UNNEST t.reviews r 
WHERE t.type = "hotel" 
LIMIT 4;</codeblock><codeblock outputclass="language-json" spectitle="Results">Results:
[
   {
      "author": "Ozella Sipes"
   },
   {
      "author": "Barton Marks"
   },
   {
      "author": "Blaise O'Connell IV"
   },
   {
      "author": "Nedra Cronin"
   }
]</codeblock></p></dd>
        </dlentry>
        <dlentry id="aggregation">
          <dt>Aggregation</dt>
          <dd>As part of a single SELECT statement, you can also perform aggregation using the SUM,
            COUNT, AVG, MIN, MAX, or ARRAY AVG functions. <p><b>Example 5</b>:  Use the COUNT
              function to count the total number of flights to SFO:
              <codeblock outputclass="language-json" spectitle="Query">SELECT count(schedule[*]) AS totalflights 
FROM `travel-sample` t 
WHERE type="route" 
  AND destinationairport="SFO";</codeblock><codeblock outputclass="language-json" spectitle="Results">Results:
[
   {
      "totalFlights": 250
   }
]</codeblock></p></dd>
        </dlentry>
        <dlentry id="combine-resultsets">
          <dt>Combining Resultsets Using Operators</dt>
          <dd>You can combine the result sets using the UNION or INTERSECT operators. <p><b>Example
                6</b>:  Use the UNION clause to look for the first schedule for flights to<codeph>
                SFO </codeph>and<codeph>
              BOS</codeph>:<codeblock outputclass="language-json" spectitle="Query">(SELECT t.schedule[0] 
 FROM `travel-sample` t 
 WHERE type = "route" 
   AND destinationairport = "SFO" 
 LIMIT  1) 
UNION ALL 
(SELECT t.schedule[0] 
 FROM `travel-sample` t 
 WHERE type = "route" 
   AND destinationairport = "BOS" 
 LIMIT  1);</codeblock><codeblock outputclass="language-json" spectitle="Results">Results:
[
   {
      "$1": {
         "day": 0,
         "flight": "AM982",
         "utc": "09:11:00"
      }
   },
   {
      "$1": {
         "day": 0,
         "flight": "AI339",
         "utc": "23:05:00"
      }
   }
]
</codeblock></p></dd>
        </dlentry>
        <dlentry id="group-sort-limit">
          <dt>Grouping, Sorting, and Limiting Results</dt>
          <dd>You can perform further processing on the data in your result set before the final
            projection is generated. You can group data using the GROUP BY clause, sort data using
            the ORDER BY clause, and you can limit the number of results included in the result set
            using the LIMIT clause. <p>Example 7:  Use the GROUP BY and ORDER BY clauses on the
              resulting list for the number of airports at an altitude of 5000 ft or higher, grouped
              by country and timezone, and then sorted by country names and timezones (ascending
              order by default).
              <codeblock outputclass="language-json" spectitle="Query">SELECT COUNT(*)  AS count, 
       t.country AS country, 
       t.tz AS timezone 
FROM `travel-sample` t 
WHERE type = "airport" 
  AND geo.alt >= 5000 
GROUP BY t.country, t.tz 
ORDER BY t.country, t.tz; </codeblock><codeblock outputclass="language-json" spectitle="Results">Results:
[
   {
      "count": 2,
      "country": "France",
      "timezone": "Europe/Paris"
   },
   {
      "count": 57,
      "country": "United States",
      "timezone": "America/Denver"
   },
   {
      "count": 7,
      "country": "United States",
      "timezone": "America/Los_Angeles"
   },
   {
      "count": 4,
      "country": "United States",
      "timezone": "America/Phoenix"
   },
   {
      "count": 1,
      "country": "United States",
      "timezone": "Pacific/Honolulu"
   }
]</codeblock></p></dd>
        </dlentry>
      </dl>
    </section>
  </body>
</topic>
